from PySide import QtCore, QtGui, QtUiTools

import os, sys

sys.path.append("d:\\github\\scriptWrangler\\")

import syntax


# TODO:
# persistent scratch pads, saved on close, maybe autosave
# store latest sizes() on resize
# clear the terminal window
# get red error text working
# if a user edits a loaded script, let him know that it's been edited and not saved with a * tab suffix
# convert tabs to spaces on text copy

def loadUiWidget(uifilename, parent=None):
    loader = QtUiTools.QUiLoader()
    uifile = QtCore.QFile(uifilename)
    uifile.open(QtCore.QFile.ReadOnly)
    ui = loader.load(uifile, parent)
    uifile.close()
    return ui


class OutputWrapper(QtCore.QObject):
    '''
    https://stackoverflow.com/questions/19855288/duplicate-stdout-stderr-in-qtextedit-widget
    '''
    outputWritten = QtCore.Signal(object, object)

    def __init__(self, parent, stdout=True):
        QtCore.QObject.__init__(self, parent)
        if stdout:
            self._stream = sys.stdout
            sys.stdout = self
        else:
            self._stream = sys.stderr
            sys.stderr = self
        self._stdout = stdout

    def write(self, text):
        self._stream.write(text)
        self.outputWritten.emit(text, self._stdout)

    def __getattr__(self, name):
        return getattr(self._stream, name)

    def __del__(self):
        try:
            if self._stdout:
                sys.stdout = self._stream
            else:
                sys.stderr = self._stream
        except AttributeError:
            pass


class ScriptWrangler(QtGui.QDialog):
    '''
    Tabs are converted to spaces only on execution.
    '''

    def __init__(self, parent=None):
        super(ScriptWrangler, self).__init__(parent)

        # figure out the UI file path
        uiFile = __file__.replace('.py', '.ui')
        print 'loading', uiFile
        self.ui = loadUiWidget(uiFile)

        # make sure it's not modal
        # self.setModal(False)
        # self.setWindowModality(QtCore.Qt.NonModal)

        # connect the UI to code
        self.ui.execute_BTN.pressed.connect(self.execute_fn)
        self.ui.load_BTN.pressed.connect(self.load_fn)
        self.ui.save_BTN.pressed.connect(self.save_fn)
        self.ui.tabs_WID.currentChanged.connect(self.tab_changed_fn)

        # set the text_wid for the tab generated by UIC
        self.ui.tabs_WID.widget(0).text_wid = self.ui.script_TEXT
        self.ui.script_TEXT.setTabStopWidth(20)

        # stdout
        self._err_color = QtCore.Qt.red
        stdout = OutputWrapper(self, True)
        stdout.outputWritten.connect(self.handleOutput)
        stderr = OutputWrapper(self, False)
        stderr.outputWritten.connect(self.handleOutput)

        # syntax highlighting
        highlight = syntax.PythonHighlighter(self.ui.script_TEXT.document())

        # key binding
        QtGui.QShortcut(QtGui.QKeySequence("Alt+Return"), self.ui.tabs_WID, self.execute_fn, context=QtCore.Qt.WidgetShortcut)

        # install event filter for MMB closing tabs
        self.ui.tabs_WID.tabBar().installEventFilter(self)
        self.ui.tabs_WID.tabBar().previousMiddleIndex = -1

        '''
        #have the terminal start closed
        self.sizes = self.ui.splitter.sizes()
        print self.sizes
        total_size = self.sizes[0] + self.sizes[1]
        self.ui.splitter.setSizes([300,300])
        '''

        self.ui.show()

    def eventFilter(self, object, event):
        if object == self.ui.tabs_WID.tabBar() and event.type() in [QtCore.QEvent.MouseButtonPress, QtCore.QEvent.MouseButtonRelease] and event.button() == QtCore.Qt.MidButton:
            tabIndex = object.tabAt(event.pos())
            if event.type() == QtCore.QEvent.MouseButtonPress:
                object.previousMiddleIndex = tabIndex
            else:
                if tabIndex != -1 and tabIndex == object.previousMiddleIndex:
                    self.onTabMiddleClick(tabIndex)
                object.previousMiddleIndex = -1
            return True
        return False

    def onTabMiddleClick(self, index):
        self.ui.tabs_WID.removeTab(index)

    # TODO Might need to call a close() and deleteLater() on this widget after removing the tab.

    def handleOutput(self, text, stdout):
        color = self.ui.terminal.textColor()
        self.ui.terminal.setTextColor(color if stdout else self._err_color)
        self.ui.terminal.moveCursor(QtGui.QTextCursor.End)
        self.ui.terminal.insertPlainText(text)
        self.ui.terminal.setTextColor(color)

    def handleButton(self):
        if QtCore.QTime.currentTime().second() % 2:
            print('Printing to stdout...')
        else:
            sys.stderr.write('Printing to stderr...\n')

    def _mark_input_lines(self, lines, console='>> '):
        marked_lines = None
        for line in lines.splitlines():
            if marked_lines == None:
                marked_lines = console + line + '\n'
            else:
                marked_lines += console + line + '\n'
        return marked_lines

    def create_new_tab(self, title, data=None):
        # TODO: this doesn't use the font size of the existing tab, even though it inherits the palette

        insertion_index = self.ui.tabs_WID.count() - 1

        # build new tab
        tab_wid = QtGui.QWidget()
        text_edit = QtGui.QPlainTextEdit()
        text_edit.setPalette(self.ui.script_TEXT.palette())

        # TODO: add data, add QPlainTextEdit
        # use this to create the first tab?

        self.ui.tabs_WID.insertTab(insertion_index, tab_wid, title)
        self.ui.tabs_WID.setCurrentIndex(insertion_index)
        new_tab = self.ui.tabs_WID.widget(insertion_index)

        vert_layout = QtGui.QVBoxLayout()
        new_tab.setLayout(vert_layout)
        vert_layout.addWidget(text_edit)
        vert_layout.setContentsMargins(3, 3, 3, 3)

        # set tab text edit
        new_tab.text_wid = text_edit
        # set tab width to feel like 4 spaces
        new_tab.text_wid.setTabStopWidth(20)
        new_tab.text_wid.setLineWrapMode(QtGui.QPlainTextEdit.NoWrap)

        # connect the syntax highlighter
        highlight = syntax.PythonHighlighter(new_tab.text_wid.document())

        # add data if available
        if data:
            text_edit.setPlainText(data)

    ## UI FUNCTIONS #############################################
    def execute_fn(self, debug=1):

        # get the correct text widget
        current_tab_index = self.ui.tabs_WID.currentIndex()
        current_tab_widget = self.ui.tabs_WID.widget(current_tab_index)
        selected = current_tab_widget.text_wid.textCursor().selection().toPlainText()

        # convert tabs to spaces
        # this is dirty, but live changing the tab to spaces on a callback is not a preferred way of doing this is seems
        input_block = current_tab_widget.text_wid.toPlainText()
        input_block.replace('\t', '    ')

        local_scope = locals()
        global_scope = globals()

        if selected:
            input_block = selected

        if self.ui.echo_commands_CHK.isChecked():
            print self._mark_input_lines(input_block)

        exec (input_block, global_scope, local_scope)

        '''
        #sizes not working, returns [0,0]
        print self.sizes
        #open terminal
        if self.ui.splitter.sizes()[1] == 0:
            print self.sizes
            self.ui.splitter.setSizes(self.sizes)
            self.ui.splitter.refresh()
        '''

    def load_fn(self):
        python_file = QtGui.QFileDialog.getOpenFileName(caption="Open Python Script", dir='C:\\\\', filter="Python Files (*.py)")
        infile = open(python_file[0], 'r')

        # convert tabs to 4 spaces
        in_text = ''
        for line in infile.readlines():
            new_line = line.replace('\t', '    ')
            if in_text == '':
                in_text = new_line
            else:
                in_text += new_line

        self.create_new_tab(title=python_file[0], data=in_text)

        infile.close()

    def save_fn(self):
        save_file = QtGui.QFileDialog.getSaveFileName(caption="Save Python Script", dir='C:\\\\', filter="Python Files (*.py)")[0]
        out_file = open(save_file, 'w')

        # get the current script
        current_tab_index = self.ui.tabs_WID.currentIndex()
        current_tab_widget = self.ui.tabs_WID.widget(current_tab_index)
        out_text = current_tab_widget.text_wid.toPlainText()

        # convert tabs to spaces
        out_text = out_text.replace('\t', '    ')

        out_file.write(out_text)

        out_file.close()

        if os.path.isfile(save_file):
            print('Script written to ' + save_file)
        else:
            print('ERROR: Script failed to write to ' + save_file)

    def tab_changed_fn(self, idx):
        # is the user clicking the '+' tab/button?
        if idx == self.ui.tabs_WID.count() - 1:
            self.create_new_tab('ScratchPad')


APP = None
if not QtGui.QApplication.instance():
    APP = QtGui.QApplication(sys.argv)

main_window = ScriptWrangler()
main_window.show()
